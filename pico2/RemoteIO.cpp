#include "hardware/sync.h"
#include "pico/time.h"

#include "RemoteIO.h"

RemoteIO::RemoteIO(System &sys) : sys(sys)
{

}

void RemoteIO::init()
{
    // FIXME: config
    spi = spi0;
    spi_init(spi, 5000000);
    gpio_set_function(32, GPIO_FUNC_SPI); // "RX"
    gpio_set_function(33, GPIO_FUNC_SPI); // CS
    gpio_set_function(34, GPIO_FUNC_SPI); // SCK
    gpio_set_function(35, GPIO_FUNC_SPI); // "TX"

    // this is not in the constructor as we always want this device listed last
    sys.addIODevice(0, 0, 0, this);

    // redirect RAM used for VGA
    sys.addMemory(0xA0000, 0x20000, nullptr);
    sys.setMemAccessCallbacks(0xA0000, 0x20000, &readMem, &writeMem, this);
}

void RemoteIO::syncStatus()
{
    // called from interrupt
    uint8_t command[1];

    command[0] = uint8_t(RemoteIOCommand::GetStatus);

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    if(!awaitResponse())
        return;

    // read data
    uint8_t res[4];
    spi_read_blocking(spi, 0xFF, res, 4);

    uint16_t inputs = res[0] | res[1] << 8;
    uint8_t dmaRequests = res[2];

    uint16_t localMask = 1 << 0 | 1 << 1 | 1 << 8 | 1 << 12; // ignore interrupts generated by chipset

    // update
    auto &chipset = sys.getChipset();
    chipset.setPICInputs((inputs & ~localMask) | (chipset.getPICInputs() & localMask));

    auto curDMARequests = chipset.getDMARequests();
    auto changed = curDMARequests ^ dmaRequests;

    for(int i = 0; i < 8; i++)
    {
        if(changed & (1 << i))
        {
            bool active = dmaRequests & (1 << i);
            chipset.dmaRequest(i, active, active ? this : nullptr);
        }
    }
}

uint8_t RemoteIO::read(uint16_t addr)
{
    uint8_t command[3];

    command[0] = uint8_t(RemoteIOCommand::ReadIO8);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    if(!awaitResponse())
        return 0xFF;

    // read data
    uint8_t b;
    spi_read_blocking(spi, 0xFF, &b, 1);

    restore_interrupts(interrupts);

    return b;
}

uint16_t RemoteIO::read16(uint16_t addr)
{
    uint8_t command[3];

    command[0] = uint8_t(RemoteIOCommand::ReadIO16);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    if(!awaitResponse())
        return 0xFF;

    // read data
    uint8_t res[2];
    spi_read_blocking(spi, 0xFF, res, 2);

    restore_interrupts(interrupts);

    return res[0] | res[1] << 8;
}

void RemoteIO::write(uint16_t addr, uint8_t data)
{
    uint8_t command[4];

    command[0] = uint8_t(RemoteIOCommand::WriteIO8);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;
    command[3] = data;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    awaitResponse();

    restore_interrupts(interrupts);
}

void RemoteIO::write16(uint16_t addr, uint16_t data)
{
    uint8_t command[5];

    command[0] = uint8_t(RemoteIOCommand::WriteIO16);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;
    command[3] = data & 0xFF;
    command[4] = data >> 8;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    awaitResponse();

    restore_interrupts(interrupts);
}

uint8_t RemoteIO::dmaRead(int ch, bool isLast)
{
    uint8_t command[2];

    command[0] = uint8_t(RemoteIOCommand::ReadDMA8);
    command[1] = ch | (isLast ? 0x80 : 0);

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    if(!awaitResponse())
        return 0xFF;

    // read data
    uint8_t b;
    spi_read_blocking(spi, 0xFF, &b, 1);

    restore_interrupts(interrupts);

    return b;
}

void RemoteIO::dmaWrite(int ch, uint8_t data)
{
    uint8_t command[3];

    command[0] = uint8_t(RemoteIOCommand::WriteDMA8);
    command[1] = ch;
    command[2] = data;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    awaitResponse();

    restore_interrupts(interrupts);
}

void RemoteIO::dmaComplete(int ch)
{
    uint8_t command[2];

    command[0] = uint8_t(RemoteIOCommand::DMAComplete);
    command[1] = ch;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    awaitResponse();

    restore_interrupts(interrupts);
}

bool RemoteIO::awaitResponse()
{
    auto timeout = make_timeout_time_ms(10);
    while(!time_reached(timeout))
    {
        uint8_t res;
        spi_read_blocking(spi, 0xFF, &res, 1);

        if(res == 0xAA) // ack
            return true;
    }
    // timed out
    return false;
}

uint8_t RemoteIO::readMem(uint32_t addr)
{
    uint8_t command[4];

    command[0] = uint8_t(RemoteIOCommand::ReadMem8);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;
    command[3] = addr >> 16;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    if(!awaitResponse())
        return 0xFF;

    // read data
    uint8_t b;
    spi_read_blocking(spi, 0xFF, &b, 1);

    restore_interrupts(interrupts);

    return b;
}

void RemoteIO::writeMem(uint32_t addr, uint8_t data)
{
    uint8_t command[5];

    command[0] = uint8_t(RemoteIOCommand::WriteMem8);
    command[1] = addr & 0xFF;
    command[2] = addr >> 8;
    command[3] = addr >> 16;
    command[4] = data;

    auto interrupts = save_and_disable_interrupts();

    spi_write_blocking(spi, command, sizeof(command));

    // wait for response
    awaitResponse();

    restore_interrupts(interrupts);
}

RemoteIOHost::RemoteIOHost(System &sys) : sys(sys)
{
}

void RemoteIOHost::init()
{
    // FIXME: config
    spi = spi0;
    statusPin = 11;

    spi_init(spi, 5000000);
    spi_set_slave(spi0, true);
    gpio_set_function(20, GPIO_FUNC_SPI); // "RX"
    gpio_set_function(21, GPIO_FUNC_SPI); // CS
    gpio_set_function(22, GPIO_FUNC_SPI); // SCK
    gpio_set_function(23, GPIO_FUNC_SPI); // "TX"

    // io for signalling that irq status has changed
    gpio_set_dir(statusPin, GPIO_OUT);
    gpio_put(statusPin, 0);
    gpio_set_function(statusPin, GPIO_FUNC_SIO);
}

void RemoteIOHost::update()
{
    if(spi_is_readable(spi))
    {
        uint8_t b;
        spi_read_blocking(spi, 0xFF, &b, 1);

        switch(static_cast<RemoteIOCommand>(b))
        {
            case RemoteIOCommand::ReadIO8:
            {
                // read addr
                uint8_t buf[2];
                spi_read_blocking(spi, 0xFF, buf, 2);
                uint16_t addr = buf[0] | buf[1] << 8;

                // do the read
                auto data = sys.readIOPort(addr);

                // reply
                buf[0] = 0xAA; // ack
                buf[1] = data;
                spi_write_blocking(spi, buf, 2);
                break;
            }

            case RemoteIOCommand::WriteIO8:
            {
                // read addr/data
                uint8_t buf[3];
                spi_read_blocking(spi, 0xFF, buf, 3);
                uint16_t addr = buf[0] | buf[1] << 8;
                uint8_t data = buf[2];

                // do the read
                sys.writeIOPort(addr, data);

                // reply
                buf[0] = 0xAA; // ack
                spi_write_blocking(spi, buf, 1);
                break;
            }

            case RemoteIOCommand::ReadIO16:
            {
                // read addr
                uint8_t buf[3];
                spi_read_blocking(spi, 0xFF, buf, 2);
                uint16_t addr = buf[0] | buf[1] << 8;

                // do the read
                auto data = sys.readIOPort16(addr);

                // reply
                buf[0] = 0xAA; // ack
                buf[1] = data;
                buf[2] = data >> 8;
                spi_write_blocking(spi, buf, 3);
                break;
            }

            case RemoteIOCommand::WriteIO16:
            {
                // read addr/data
                uint8_t buf[4];
                spi_read_blocking(spi, 0xFF, buf, 4);
                uint16_t addr = buf[0] | buf[1] << 8;
                uint16_t data = buf[2] | buf[3] << 8;

                // do the read
                sys.writeIOPort16(addr, data);

                // reply
                buf[0] = 0xAA; // ack
                spi_write_blocking(spi, buf, 1);
                break;
            }

            case RemoteIOCommand::ReadMem8:
            {
                // read addr
                uint8_t buf[3];
                spi_read_blocking(spi, 0xFF, buf, 3);
                uint32_t addr = buf[0] | buf[1] << 8 | buf[2] << 16;

                // do the read
                auto data = sys.readMem(addr);

                // reply
                buf[0] = 0xAA; // ack
                buf[1] = data;
                spi_write_blocking(spi, buf, 2);
                break;
            }

            case RemoteIOCommand::WriteMem8:
            {
                // read addr/data
                uint8_t buf[4];
                spi_read_blocking(spi, 0xFF, buf, 4);
                uint32_t addr = buf[0] | buf[1] << 8 | buf[2] << 16;
                uint8_t data = buf[3];

                // do the read
                sys.writeMem(addr, data);

                // reply
                buf[0] = 0xAA; // ack
                spi_write_blocking(spi, buf, 1);
                break;
            }

            case RemoteIOCommand::ReadDMA8:
            {
                // read channel
                uint8_t buf[2];
                spi_read_blocking(spi, 0xFF, buf, 1);
                int ch = buf[0] & 7;
                bool isLast = buf[0] & 0x80;

                // do the read
                auto dev = sys.getChipset().getDMARequestDev(ch);
                auto data = dev ? dev->dmaRead(ch, isLast) : 0xFF;

                // reply
                buf[0] = 0xAA; // ack
                buf[1] = data;
                spi_write_blocking(spi, buf, 2);
                break;
            }

            case RemoteIOCommand::WriteDMA8:
            {
                // read channel/data
                uint8_t buf[2];
                spi_read_blocking(spi, 0xFF, buf, 2);
                int ch = buf[0];
                uint8_t data = buf[1];

                // do the read
                auto dev = sys.getChipset().getDMARequestDev(ch);
                if(dev)
                    dev->dmaWrite(ch, data);

                // reply
                buf[0] = 0xAA; // ack
                spi_write_blocking(spi, buf, 1);
                break;
            }

            case RemoteIOCommand::DMAComplete:
            {
                // read channel
                uint8_t buf[2];
                spi_read_blocking(spi, 0xFF, buf, 1);
                int ch = buf[0];

                // do the read
                auto dev = sys.getChipset().getDMARequestDev(ch);
                if(dev)
                    dev->dmaComplete(ch);

                // reply
                buf[0] = 0xAA; // ack
                spi_write_blocking(spi, buf, 1);
                break;
            }

            case RemoteIOCommand::GetStatus:
            {
                uint8_t buf[5];

                auto picInputs = sys.getChipset().getPICInputs();
                auto dmaRequests = sys.getChipset().getDMARequests();

                // reply
                buf[0] = 0xAA; // ack
                buf[1] = picInputs;
                buf[2] = picInputs >> 8;
                buf[3] = dmaRequests;
                buf[4] = 0;
                spi_write_blocking(spi, buf, 5);

                setStatusPin(false);
                lastPICInputs = picInputs; // try not to immediately request sync again
                lastDMARequests = dmaRequests;
                break;
            }
        }
    }

    // check if we need to do a status update
    auto &chipset = sys.getChipset();
    if(chipset.getPICInputs() != lastPICInputs || chipset.getDMARequests() != lastDMARequests)
    {
        setStatusPin(true);
        lastPICInputs = chipset.getPICInputs();
        lastDMARequests = chipset.getDMARequests();
    }
}

void RemoteIOHost::setStatusPin(bool status)
{
    statusPinActive = status;
    gpio_put(statusPin, status);
}